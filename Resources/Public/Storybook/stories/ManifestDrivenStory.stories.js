// Resources/Public/Storybook/stories/ManifestDrivenStory.stories.js

/**
 * Helper function to get template options from the globally loaded manifest.
 * This function is called when the story module is evaluated.
 */
const getManifestTemplateOptions = () => {
  // @ts-ignore
  const manifest = window.templateManifestData;

  if (manifest && manifest.templates && manifest.templates.length > 0) {
    return manifest.templates.map(t => ({
      // Storybook's select control options can be an array of strings (values)
      // or an object for mapping values to titles. We'll provide simple paths as values
      // and use argTypes.mapping for nicer titles if needed, or just show paths.
      // For simplicity here, value and title will be the path, or a shortened form for title.
      value: t.path,
      title: `${t.name} (${t.extension}) - ${t.path.substring(t.path.lastIndexOf('/') + 1)}` // Example: "SimpleStory (my_fluid_storybook) - SimpleStory.html"
    }));
  } else if (manifest && manifest.error) {
    return [{ value: '', title: `Error loading manifest: ${manifest.error}` }];
  }
  return [{ value: '', title: 'Manifest empty/not loaded. Run CLI & refresh.' }];
};

const initialTemplateOptions = getManifestTemplateOptions();

/**
 * This story demonstrates using the `template-manifest.json`
 * (generated by `vendor/bin/typo3 storybook:generate-manifest`)
 * to dynamically populate a dropdown (argType) for selecting Fluid templates.
 * The options for the dropdown are populated when Storybook loads this story file.
 * If the manifest changes, a Storybook refresh might be needed.
 */
export default {
  title: 'TYPO3 Fluid/Manifest Driven Story',
  tags: ['autodocs'],
  argTypes: {
    selectedTemplatePath: {
      name: 'Select Template (from Manifest)',
      control: 'select',
      options: initialTemplateOptions.map(opt => opt.value), // Values for the select
      mapping: initialTemplateOptions.reduce((acc, opt) => { // Display names for the select
        acc[opt.value] = opt.title;
        return acc;
      }, {}),
      description: 'Choose a Fluid template path from the generated manifest. Requires `template-manifest.json` to be present (run TYPO3 CLI `storybook:generate-manifest` and refresh Storybook if list is empty/stale).',
    },
    variables: {
      control: 'object',
      description: 'JSON object of variables to pass to the selected template.',
      defaultValue: { headline: "Default Headline", content: "Some default content for the selected template." }
    },
  },
};

const Template = (args) => {
  const container = document.createElement('div');
  // @ts-ignore (FluidTemplate is on window for now)
  const ft = window.FluidTemplate;

  if (typeof ft !== 'function') {
    container.innerHTML = 'Error: FluidTemplate function is not available.';
    return container;
  }
  if (!args.selectedTemplatePath) {
    // @ts-ignore
    const manifestError = window.templateManifestData?.error;
    let message = '<p>Please select a template from the manifest.</p>';
    if (initialTemplateOptions.length === 1 && initialTemplateOptions[0].value === '') {
        message += '<p>If the list is empty or shows an error, run the TYPO3 CLI command: <code>./vendor/bin/typo3 storybook:generate-manifest</code> and refresh Storybook.</p>';
    }
    if (manifestError) {
        message += `<p style="color:orange;">Manifest loading issue: ${manifestError}</p>`;
    }
    container.innerHTML = message;
    return container;
  }

  ft({ templatePath: args.selectedTemplatePath, variables: args.variables || {} })
    .then(html => {
      container.innerHTML = html;
    })
    .catch(error => {
      container.innerHTML = `<pre style="color:red; border:1px solid red; padding:10px;"><strong>Error rendering ${args.selectedTemplatePath}:</strong><br>${error.message || JSON.stringify(error.details || error)}</pre>`;
    });
  return container;
};

export const SelectAndRender = Template.bind({});
SelectAndRender.args = {
  // Try to set a default selection if possible, otherwise let it be empty.
  selectedTemplatePath: initialTemplateOptions.length > 0 && initialTemplateOptions[0].value !== '' ? initialTemplateOptions[0].value : '',
  variables: {
    headline: 'Hello from Manifest!',
    myTextValue: 'This text will be uppercased by Fluid.',
    myArray: [{name: 'Item 1 from Manifest Story'}, {name: 'Item 2 from Manifest Story'}],
    // Default variables that might be useful for many templates from my_fluid_storybook
    mainHeadline: "Default Main Headline",
    showExtraInfo: true,
    extraInfoText: "Default extra info text.",
    items: [{ id: 1, name: 'Default Item', description: 'Default item description' }],
    status: 'new',
    content: "Default content text for simple templates.",
    record: { uid: 0, header: "Default Record Header", bodytext: "Default record bodytext."}
  },
};

// The loader is not strictly needed anymore for populating argTypes.options in this revised approach,
// as options are set at definition time. However, a loader *could* be used to dynamically
// set the *initial default selected value* of `selectedTemplatePath` if desired,
// or to fetch other data. For now, we set the default in `SelectAndRender.args`.
// If we wanted to ensure the latest manifest data populates the default arg:
/*
SelectAndRender.loaders = [
  async () => {
    // @ts-ignore
    const manifest = window.templateManifestData;
    let defaultPath = '';
    if (manifest && manifest.templates && manifest.templates.length > 0 && manifest.templates[0].value !== '') {
      defaultPath = manifest.templates[0].value;
    }
    return {
      // This would allow updating the args based on the freshly loaded manifest if Storybook handles it for initialArgs
      // For now, direct assignment in .args with initialTemplateOptions is simpler.
    };
  }
];
*/
